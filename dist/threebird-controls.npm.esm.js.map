{"version":3,"file":"threebird-controls.npm.esm.js","sources":["../node_modules/tslib/tslib.es6.js","../src/CameraRig.ts","../src/Damper.ts","../src/adaptors/BaseAdaptor.ts","../src/adaptors/KeyboardAdaptor.ts","../src/adaptors/PointerAdaptor.ts","../src/adaptors/ScrollAdaptor.ts","../src/adaptors/SwipeAdaptor.ts","../src/adaptors/WheelAdaptor.ts","../src/controlschemes/FreeMovementControls.ts","../src/controlschemes/ScrollControls.ts","../src/controlschemes/StoryPointsControls.ts","../src/controlschemes/PathPointsControls.ts","../src/controlschemes/ThreeDOFControls.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","import {\n  Vector3,\n  Quaternion,\n  Object3D,\n  Camera,\n  PerspectiveCamera,\n  Scene,\n  AnimationMixer,\n  AnimationClip,\n  EventDispatcher,\n} from 'three'\n\nimport { TweenMax } from 'gsap'\n\n/**\n * Event: Fired when CameraRig starts a transition\n * @example\n * ```javascript\n * rig.on('CameraMoveStart', () => {\n *   // do something\n * })\n * ```\n * */\nexport interface CameraMoveStartEvent {\n  type: 'CameraMoveStart'\n}\n\n/**\n * Event: Fired on every tick of CameraRig's transition\n * @example\n * ```javascript\n * rig.on('CameraMoveUpdate', (e) => {\n *   console.log(e.progress)\n * })\n * ```\n * */\nexport interface CameraMoveUpdateEvent {\n  type: 'CameraMoveUpdate'\n  /** Percentage of transition completed, between 0 and 1. */\n  progress: number\n}\n\n/**\n * Event: Fired when CameraRig ends a transition\n * @example\n * ```javascript\n * rig.on('CameraMoveEnd', (e) => {\n *   // do something\n * })\n * ```\n * */\nexport interface CameraMoveEndEvent {\n  type: 'CameraMoveEnd'\n}\n\nexport enum CameraAction {\n  Pan = 'Pan',\n  Tilt = 'Tilt',\n  Roll = 'Roll',\n  Truck = 'Truck',\n  Pedestal = 'Pedestal',\n  Dolly = 'Dolly',\n  LocalTruck = 'LocalTruck',\n  LocalPedestal = 'LocalPedestal',\n  LocalDolly = 'LocalDolly',\n  Zoom = 'Zoom',\n  /* TODO \"Orbit\" = \"Orbit\" */\n}\n\nexport enum Axis {\n  X = 'X',\n  Y = 'Y',\n  Z = 'Z',\n}\n\ninterface ActionAxes {\n  [CameraAction.Pan]: Axis\n  [CameraAction.Tilt]: Axis\n  [CameraAction.Roll]: Axis\n}\n\ninterface RotationBox {\n  [Axis.X]: Object3D\n  [Axis.Y]: Object3D\n  [Axis.Z]: Object3D\n}\n\nexport interface TranslateGuide {\n  [CameraAction.Pan]: boolean\n  [CameraAction.Tilt]: boolean\n  [CameraAction.Roll]: boolean\n}\n\nconst ActionMappingByUpAxis = {\n  [Axis.X]: {\n    [CameraAction.Pan]: Axis.X,\n    [CameraAction.Tilt]: Axis.Z,\n    [CameraAction.Roll]: Axis.Y,\n  },\n  [Axis.Y]: {\n    [CameraAction.Pan]: Axis.Y,\n    [CameraAction.Tilt]: Axis.X,\n    [CameraAction.Roll]: Axis.Z,\n  },\n  [Axis.Z]: {\n    [CameraAction.Pan]: Axis.Z,\n    [CameraAction.Tilt]: Axis.X,\n    [CameraAction.Roll]: Axis.Y,\n  },\n}\n\nexport interface CameraRigProps {\n  upAxis?: Axis\n  preventActionsWhileTransitioning?: boolean\n}\n\n/**\n * The CameraRig holds the camera, and can respond to actions such as Pan/Tilt/Dolly etc. It can also be controlled along a given path (in the form of an `AnimationClip`), or tweened to specified points.\n *\n * @remarks\n * The rig is made of 5 objects and a camera\n * A translation box with default name 'Translation',\n * A rotation box with default name 'Rotation',\n * with 3 nested objects (rotation components) -\n * each responsible for rotation around 1 axis\n *\n * The naming of 'Translation' and 'Rotation' is to ensure the rig naming\n * matches that of an animation clip, if provided -- making it trivial to\n * switch in and out of using an animation clip. These names can be\n * provided in the constructor props - to match the setup of the 3d tool used to\n * create the animation\n *\n * The camera actions Pan/Tilt/Roll control the inner rotation components,\n * not the rotation box. This allows for a seperation of a 'base' rotation\n * if needed (for example, the animation clip only controls the rotation box,\n * so the inner components are free to rotate anchored at this base. Similarly, moving\n * the rig to a specific position/orientation sets the rotation of the box,\n * leaving the components to control 3dof)\n *\n * The order of rotation is dependant on the current Up axis\n * Instead of having to remember the order, and keep track of axes visually,\n * Each axis is labelled by a camera action - Pan, Tilt, and Roll\n * When the Up axis is Y, for example, the Pan axis is Y, Tilt is X, and Roll is Z\n * Similarly, this is defined for the other possible Up axes\n * The order of rotation (and object nesting) is always Pan - Tilt - Roll\n *\n * Additionaly, it can be specified if the rig should be translated along\n * the current rotation direction any of the axes.\n * The default is to translate along the Pan axis (Y default), ie the rig will\n * move forward/backward in the direction the camera is panned to.\n *\n * The camera actions concerned with translation are Truck/Pedestal/Dolly\n * Again, instead of specifying x/y/z axes,\n * Truck is translation on the Tilt axis\n * Pedestal is translation on the Pan axis\n * and Dolly is translation on the Roll axis\n *\n * For 3dof controls, there are additional translate actions called\n * LocalTruck / LocalPedestal / LocalDolly\n * These will translate the inner rotation components, and perhaps\n * should not be used when creating 6dof controls.\n */\nexport class CameraRig extends EventDispatcher {\n  readonly camera: Camera\n  readonly scene: Scene\n  private translationBox: Object3D\n  private rotationBox: Object3D\n  private rotationElements: RotationBox\n  private cameraIsInRig: boolean\n  private inTransit = false\n  // private preventActionsWhileTransitioning = true\n  private upAxis: Axis = Axis.Y\n  private actionAxes: ActionAxes = ActionMappingByUpAxis[this.upAxis]\n  private hasAnimation = false\n  private animationClip: AnimationClip\n  private mixer: AnimationMixer\n  private animationTranslationObjectName = 'Translation'\n  private animationRotationObjectName = 'Rotation'\n\n  public respondsToActions = true\n\n  // is this needed or should translation always occur along the Pan axis?\n  public translateAlong: TranslateGuide = {\n    [CameraAction.Tilt]: false,\n    [CameraAction.Pan]: true,\n    [CameraAction.Roll]: false,\n  }\n\n  // Constructor\n  constructor(camera: Camera, scene: Scene, props: CameraRigProps = {}) {\n    super()\n    this.camera = camera\n    this.scene = scene\n    Object.assign(this, props)\n    this.initRig()\n  }\n\n  private initRig(): void {\n    this.translationBox = new Object3D()\n    this.rotationBox = new Object3D()\n    this.rotationElements = {\n      [Axis.X]: new Object3D(),\n      [Axis.Y]: new Object3D(),\n      [Axis.Z]: new Object3D(),\n    }\n    this.rotationBox.name = this.animationRotationObjectName\n    this.translationBox.name = this.animationTranslationObjectName\n    this.translationBox.rotation.order = this.getRotationOrder()\n    const first = this.rotationElements[this.actionAxes[CameraAction.Pan]]\n    const second = this.rotationElements[this.actionAxes[CameraAction.Tilt]]\n    const third = this.rotationElements[this.actionAxes[CameraAction.Roll]]\n    this.scene.add(this.translationBox.add(this.rotationBox.add(first.add(second.add(third.add(this.camera))))))\n    this.cameraIsInRig = true\n  }\n\n  // rotate component on axis by degrees\n  private rotateRigComponent(rigComponent: Object3D, axis: Axis, degrees: number): void {\n    switch (axis) {\n      case Axis.X:\n        rigComponent.rotateX(degrees)\n        break\n      case Axis.Y:\n        rigComponent.rotateY(degrees)\n        break\n      case Axis.Z:\n        rigComponent.rotateZ(degrees)\n        break\n      default:\n        break\n    }\n  }\n\n  // rotate degrees for given camera action\n  private rotate(action: CameraAction, degrees: number): void {\n    const axis = this.actionAxes[action]\n    if (this.translateAlong[action]) {\n      this.rotateRigComponent(this.translationBox, axis, degrees)\n    } else {\n      this.rotateRigComponent(this.rotationElements[axis], axis, degrees)\n    }\n  }\n\n  // translate on axis by amount\n  private translateRigComponent(rigComponent: Object3D, axis: Axis, amount: number): void {\n    switch (axis) {\n      case Axis.X:\n        rigComponent.translateX(amount)\n        break\n      case Axis.Y:\n        rigComponent.translateY(amount)\n        break\n      case Axis.Z:\n        rigComponent.translateZ(amount)\n        break\n    }\n  }\n\n  /**\n   * Set an animation clip for the rig\n   * @param {AnimationClip} clip - AnimationClip containing a VectorKeyFrameTrack for position and a QuaternionKeyFrameTrack for rotation\n   * @param {string} translationObjectName - Name of translation object\n   * @param {string} rotationObjectName -  Name of rotation object\n   */\n  setAnimationClip(clip: AnimationClip, translationObjectName?: string, rotationObjectName?: string): void {\n    this.animationClip = clip\n    if (translationObjectName) this.animationTranslationObjectName = translationObjectName\n    if (rotationObjectName) this.animationRotationObjectName = rotationObjectName\n    this.hasAnimation = true\n    this.mixer = new AnimationMixer(this.translationBox)\n    const action = this.mixer.clipAction(this.animationClip)\n    action.play()\n    this.mixer.setTime(0)\n  }\n\n  /**\n   * Main method for controlling the camera\n   * @param action - Action to perform\n   * @param amount - Amount to move/rotate/etc\n   */\n  do(action: CameraAction, amount: number): void {\n    if (this.respondsToActions) {\n      switch (action) {\n        case CameraAction.Pan:\n        case CameraAction.Tilt:\n        case CameraAction.Roll:\n          this.rotate(action, amount)\n          break\n        case CameraAction.Truck:\n          this.translateRigComponent(this.translationBox, this.actionAxes[CameraAction.Tilt], amount)\n          break\n        case CameraAction.Pedestal:\n          this.translateRigComponent(this.translationBox, this.actionAxes[CameraAction.Pan], amount)\n          break\n        case CameraAction.Dolly:\n          this.translateRigComponent(this.translationBox, this.actionAxes[CameraAction.Roll], amount)\n          break\n        case CameraAction.LocalTruck:\n          {\n            const axis = this.actionAxes[CameraAction.Tilt]\n            this.translateRigComponent(this.rotationElements[axis], axis, amount)\n          }\n          break\n        case CameraAction.LocalPedestal:\n          {\n            const axis = this.actionAxes[CameraAction.Pan]\n            this.translateRigComponent(this.rotationElements[axis], axis, amount)\n          }\n          break\n        case CameraAction.LocalDolly:\n          {\n            const axis = this.actionAxes[CameraAction.Roll]\n            this.translateRigComponent(this.rotationElements[axis], axis, amount)\n          }\n          break\n        case CameraAction.Zoom:\n          if (this.camera instanceof PerspectiveCamera) {\n            this.camera.fov = amount\n            this.camera.updateProjectionMatrix()\n          }\n          break\n        default:\n          break\n      }\n    }\n  }\n\n  // TODO: add 'unpackTransform', change freeze to 'pack'\n\n  /**\n   * Packs transfrom into parent translation and rotation elements,\n   * and 0s out transforms for all inner elements. Useful to use before\n   * procedural animation on world position and quaternion\n   */\n  freezeTransform(): void {\n    const { position, quaternion } = this.getWorldCoordinates()\n    this.translationBox.position.copy(position)\n    this.translationBox.rotation.set(0, 0, 0)\n    this.rotationBox.quaternion.copy(quaternion)\n    this.rotationBox.position.set(0, 0, 0)\n    for (const key in this.rotationElements) {\n      this.rotationElements[key].position.set(0, 0, 0)\n      this.rotationElements[key].rotation.set(0, 0, 0)\n    }\n  }\n\n  /**\n   * Disassemble the camera from the rig and attach it to the scene.\n   * Useful if one needs to set the camera's world position or\n   * control it outside of the rig setup\n   */\n  disassemble(): void {\n    if (this.cameraIsInRig) {\n      this.scene.attach(this.camera)\n      this.cameraIsInRig = false\n    }\n  }\n\n  /**\n   * Place the camera back in the rig\n   */\n  // TODO: rethink freeze/unfreeze and assemble/disassemble transforms\n  assemble(): void {\n    if (!this.cameraIsInRig) {\n      const { position, quaternion } = this.getWorldCoordinates()\n      this.translationBox.position.copy(position)\n      this.rotationBox.quaternion.copy(quaternion)\n      this.rotationElements[this.actionAxes[CameraAction.Roll]].attach(this.camera)\n      this.cameraIsInRig = true\n    }\n  }\n\n  /**\n   * @returns Whether the camera is attached to the rig\n   */\n  isInRig(): boolean {\n    return this.cameraIsInRig\n  }\n\n  /**\n   * Get the rotaion order as a string compatible with what three.js uses\n   */\n  getRotationOrder(): string {\n    return Object.values(this.actionAxes).join('')\n  }\n\n  /**\n   * Get world position and orientation of the camera\n   */\n  getWorldCoordinates(): { position: Vector3; quaternion: Quaternion } {\n    const position = new Vector3()\n    this.camera.getWorldPosition(position)\n    const quaternion = new Quaternion()\n    this.camera.getWorldQuaternion(quaternion)\n    return { position, quaternion }\n  }\n\n  /**\n   * If the camera is in the middle of a transition\n   */\n  isMoving(): boolean {\n    return this.inTransit\n  }\n\n  /**\n   * Set the Up axis for the camera, adjusting the rotation components accordingly\n   * to maintain consistent Pan/Tilt/Roll behaviour\n   * ... might not be necessary, rotationBox transforms could take care of setting context\n   * @param axis - New Up axis\n   */\n  setUpAxis(axis: Axis): void {\n    const currentAxes = this.actionAxes\n    this.upAxis = axis\n    this.actionAxes = ActionMappingByUpAxis[this.upAxis]\n\n    const currentPanObject = this.rotationElements[currentAxes[CameraAction.Pan]]\n    const currentTiltObject = this.rotationElements[currentAxes[CameraAction.Tilt]]\n    const currentRollObject = this.rotationElements[currentAxes[CameraAction.Roll]]\n    // reassign objects to retain nesting\n    this.rotationElements[this.actionAxes[CameraAction.Pan]] = currentPanObject\n    this.rotationElements[this.actionAxes[CameraAction.Tilt]] = currentTiltObject\n    this.rotationElements[this.actionAxes[CameraAction.Roll]] = currentRollObject\n\n    this.translationBox.rotation.order = this.getRotationOrder()\n  }\n\n  /**\n   * Transition to a specific position and orientation in world space.\n   * All inner rotation components will be reset to 0 as a result of this.\n   * @param position\n   * @param quaternion\n   * @param duration\n   * @param ease\n   */\n  flyTo(position: Vector3, quaternion: Quaternion, duration = 1, ease = 'power1'): void {\n    if (!this.isMoving()) {\n      const currentCoords = this.getWorldCoordinates()\n      const currentValues = {\n        px: currentCoords.position.x,\n        py: currentCoords.position.y,\n        pz: currentCoords.position.z,\n        qx: currentCoords.quaternion.x,\n        qy: currentCoords.quaternion.y,\n        qz: currentCoords.quaternion.z,\n        qw: currentCoords.quaternion.w,\n      }\n      const targetValues = {\n        px: position.x,\n        py: position.y,\n        pz: position.z,\n        qx: quaternion.x,\n        qy: quaternion.y,\n        qz: quaternion.z,\n        qw: quaternion.w,\n      }\n      const onStart = (): void => {\n        this.inTransit = true\n        this.disassemble()\n        this.dispatchEvent({ type: 'CameraMoveStart' } as CameraMoveStartEvent)\n      }\n      const onUpdate = (tween: TweenMax): void => {\n        this.camera.position.set(currentValues.px, currentValues.py, currentValues.pz)\n        this.camera.quaternion.set(currentValues.qx, currentValues.qy, currentValues.qz, currentValues.qw)\n        this.dispatchEvent({\n          type: 'CameraMoveUpdate',\n          progress: tween.progress(),\n        } as CameraMoveUpdateEvent)\n      }\n      const onComplete = (): void => {\n        this.assemble()\n        this.inTransit = false\n        this.dispatchEvent({ type: 'CameraMoveEnd' } as CameraMoveEndEvent)\n      }\n      TweenMax.to(currentValues, {\n        duration,\n        ease,\n        ...targetValues,\n        onStart,\n        onUpdate: function () {\n          onUpdate(this)\n        },\n        onComplete,\n      })\n    }\n  }\n\n  /**\n   * Transition to a specific keyframe on the animation clip\n   * All inner rotation components will be reset to 0 as a result of this.\n   * @param frame - frame\n   * @param duration - duration\n   * @param ease - ease\n   */\n  flyToKeyframe(frame: number, duration = 1, ease = 'power1'): void {\n    if (this.hasAnimation && !this.isMoving()) {\n      const currentValues = {\n        time: this.mixer.time,\n      }\n      const targetValues = {\n        time: this.animationClip.tracks[0].times[frame],\n      }\n      const onStart = (): void => {\n        this.inTransit = true\n        this.dispatchEvent({ type: 'CameraMoveStart' } as CameraMoveStartEvent)\n      }\n      const onUpdate = (tween: TweenMax): void => {\n        this.mixer.setTime(currentValues.time)\n        this.dispatchEvent({\n          type: 'CameraMoveUpdate',\n          progress: tween.progress(),\n        } as CameraMoveUpdateEvent)\n      }\n      const onComplete = (): void => {\n        this.inTransit = false\n        this.dispatchEvent({ type: 'CameraMoveEnd' } as CameraMoveEndEvent)\n      }\n      TweenMax.to(currentValues, {\n        duration,\n        ease,\n        ...targetValues,\n        onStart,\n        onUpdate: function () {\n          onUpdate(this)\n        },\n        onComplete,\n      })\n    }\n  }\n\n  /**\n   * @param percentage - percentage of animation clip to move to, between 0 and 1\n   */\n  setAnimationPercentage(percentage: number): void {\n    if (this.hasAnimation) {\n      const percent = Math.max(\n        0,\n        Math.min(percentage * this.animationClip.duration, this.animationClip.duration - 0.0001),\n      )\n      this.mixer.setTime(percent)\n    }\n  }\n\n  /**\n   * @param time - timestamp of animation clip to move to\n   */\n  setAnimationTime(time: number): void {\n    if (this.hasAnimation) this.mixer.setTime(time)\n  }\n\n  /**\n   * @param frame - frame of animation clip to move to\n   */\n  setAnimationKeyframe(frame: number): void {\n    if (this.hasAnimation) this.mixer.setTime(this.animationClip.tracks[0].times[frame])\n  }\n}\n","export interface DamperValues {\n  /** A value to dampen, set to its initial state  */\n  [key: string]: number | null\n}\n\nexport interface DamperProps {\n  /**  Values to be dampened */\n  values: DamperValues\n  /** Multiplier used on each update to approach the target value, should be between 0 and 1, where 1 is no damping */\n  dampingFactor: number\n  /** Amount of permitted error before a value is considered to have 'reached' its target. Defaults to 0.001 */\n  epsilon?: number\n}\n\n/**\n * Damper uses simple linear damping for a given collection of values.\n * On every call to update, the damper will approach a given set of target values.\n * @example\n * ```js\n * const damper = new Damper({\n *  values: {x: 0, y: 0},\n *  dampingFactor: 0.4\n * })\n *\n * damper.setTarget({ x: 1, y: 100 })\n * damper.update() // would generally be called in an animation loop\n * const values = damper.getCurrentValues() // values.x = 0.4; values.y = 40\n * ```\n */\n\nexport class Damper {\n  private dampingFactor: number\n  private epsilon = 0.001\n  private values: DamperValues = {}\n  private targetValues: DamperValues = {}\n  private deltaValues: DamperValues = {}\n  private hasReached: boolean\n\n  constructor(props: DamperProps) {\n    Object.assign(this.values, props.values)\n    Object.assign(this.targetValues, props.values)\n    this.deltaValues = {}\n    for (const key in this.values) {\n      this.deltaValues[key] = 0\n    }\n    this.dampingFactor = props.dampingFactor\n    if (props.epsilon) this.epsilon = props.epsilon\n    this.hasReached = true\n  }\n\n  /**\n   * Update the damper, should generally be called on every frame\n   */\n  update(): void {\n    const deltas = {}\n    let approached = true\n\n    for (const key in this.values) {\n      deltas[key] = this.targetValues[key] - this.values[key]\n      approached = approached && Math.abs(deltas[key]) < this.epsilon\n    }\n\n    if (approached) {\n      for (const key in this.values) {\n        this.deltaValues[key] = deltas[key]\n        this.values[key] = this.targetValues[key]\n      }\n      this.hasReached = true\n    } else {\n      for (const key in this.values) {\n        this.deltaValues[key] = this.dampingFactor * deltas[key]\n        this.values[key] += this.deltaValues[key]\n      }\n    }\n  }\n\n  /**\n   * @param target DamperValues the damper needs to approach\n   */\n  setTarget(target: DamperValues): void {\n    for (const key in target) {\n      this.targetValues[key] = target[key]\n    }\n    this.hasReached = false\n  }\n\n  /**\n   * Increment/Decrement a specifc damper target value\n   * @param key The key of the value to modify\n   * @param value The amount to modify the target by\n   */\n  addToTarget(key: string, value: number): void {\n    this.targetValues[key] += value\n    this.hasReached = false\n  }\n\n  /**\n   * @param value Number to reset all damper values to\n   */\n  resetAll(value: number): void {\n    for (const key in this.values) {\n      this.targetValues[key] = value\n      this.values[key] = value\n      this.deltaValues[key] = 0\n    }\n    this.hasReached = true\n  }\n\n  /**\n   * Reset damper values as described by the given DamperValues object\n   * @param values DamperValues object to reset the damper to\n   */\n  resetData(values: DamperValues): void {\n    for (const key in values) {\n      this.targetValues[key] = values[key]\n      this.values[key] = values[key]\n      this.deltaValues[key] = 0\n    }\n    this.hasReached = true\n  }\n\n  /**\n   * @returns DamperValues object with the current values of the damper\n   */\n  getCurrentValues(): DamperValues {\n    return { ...this.values }\n  }\n\n  /**\n   * @returns DamperValues object with the amount the values changed since the last `update()` call\n   */\n  getDeltaValues(): DamperValues {\n    return { ...this.deltaValues }\n  }\n\n  /**\n   * @returns Whether the damper has reached its target (within permissible error range)\n   */\n  reachedTarget(): boolean {\n    return this.hasReached\n  }\n}\n","import { EventDispatcher } from 'three'\n\nexport abstract class BaseAdaptor extends EventDispatcher {\n  constructor() {\n    super()\n  }\n  abstract connect(): void\n  abstract disconnect(): void\n  abstract update(time?: number): void\n  abstract isEnabled(): boolean\n}\n\nexport interface DiscreteEvent {\n  type: 'trigger'\n}\n\nexport interface ContinuousEvent {\n  type: 'update'\n}\n\nexport interface IntertiaCompleteEvent {\n  type: 'inertiacomplete'\n}\n","import { BaseAdaptor, DiscreteEvent, ContinuousEvent, IntertiaCompleteEvent } from './BaseAdaptor'\nimport { Damper, DamperValues } from '../Damper'\n\n/**\n * Event: Fired when a key in a `discrete` KeyboardAdaptor's mapping is released (`onKeyUp`)\n * @example\n * ```javascript\n * adaptor.on('trigger', () => {\n *   // do something\n * })\n * ```\n * */\nexport interface KeyboardAdaptorDiscreteEvent extends DiscreteEvent {\n  /** KeyMapping key that triggered the event */\n  trigger: string\n}\n\n/**\n * Event: Fired when a key in a `continuous` KeyboardAdaptor's mapping is pressed (`onKeyDown`)\n * @example\n * ```javascript\n * adaptor.on('update', () => {\n *   // do something\n * })\n * ```\n * */\nexport interface KeyboardAdaptorContinuousEvent extends ContinuousEvent {\n  values: DamperValues\n  deltas: DamperValues\n}\n\n/**\n * A discrete adaptor works as a trigger - only firing events on keyup,\n * whereas a continuous adaptor continuously fires events on keydown\n * */\nexport type KeyboardAdaptorType = 'discrete' | 'continuous'\n\nexport interface KeyMapping {\n  /** The key is a semantic label, and the string[] is a corresponding collection of event.keys */\n  [key: string]: string[]\n}\n\nexport interface KeyboardAdaptorProps {\n  type: KeyboardAdaptorType\n  /**\n   * Default key mapping uses up/down/left/right as semanic labels, with WASD and arrow keys mapped appropriately:\n   * @example keyMapping\n   * ```javascript\n   * {\n   *   up: ['ArrowUp', 'w', 'W'],\n   *   down: ['ArrowDown', 's', 'S'],\n   *   left: ['ArrowLeft', 'a', 'A'],\n   *   right: ['ArrowRight', 'd', 'D'],\n   * }\n   * ```\n   * */\n  keyMapping?: KeyMapping\n  /** Only used for continuous adaptor, value between 0 and 1. Defaults to 0.5 */\n  dampingFactor?: number\n  /** Only used for continuous adaptor, the amount to increment the target value on each keydown event. Defaults to 1 */\n  incrementor?: number\n  /** Prevent event bubbling. Defaults to true */\n  preventBubbling?: boolean\n}\n\n/**\n * Parse keyboard events and emit either dampened values for continuous keypresses, or trigger events named according to a provided keymapping.\n * @example Continuous adaptor\n * ```javascript\n * const keyboardAdaptor = new KeyboardAdaptor({ type: 'continuous', dampingFactor: 0.2 })\n * keyboardAdaptor.connect()\n * keyboardAdaptor.addEventListener('update', (event) => {\n *   cube.rotation.y += event.deltas.right - event.deltas.left\n *   cube.rotation.x += event.deltas.up - event.deltas.down\n * )}\n * function animate() {\n *  keyboardAdaptor.update()\n *  window.requestAnimationFrame(animate)\n * }\n * animate()\n * ```\n */\nexport class KeyboardAdaptor extends BaseAdaptor {\n  private type: KeyboardAdaptorType\n  private damper: Damper\n  private dampingFactor = 0.5\n  private incrementor = 1\n  private keyMapping: KeyMapping = {\n    up: ['ArrowUp', 'w', 'W'],\n    down: ['ArrowDown', 's', 'S'],\n    left: ['ArrowLeft', 'a', 'A'],\n    right: ['ArrowRight', 'd', 'D'],\n  }\n  private connected: boolean\n  private preventBubbling = true\n\n  constructor(props: KeyboardAdaptorProps) {\n    super()\n    Object.assign(this, props)\n    const values = {}\n    for (const key in this.keyMapping) {\n      values[key] = 0\n    }\n    this.damper = new Damper({\n      values,\n      dampingFactor: this.dampingFactor,\n    })\n    this.onKeyUp = this.onKeyUp.bind(this)\n    this.onKeyDown = this.onKeyDown.bind(this)\n  }\n\n  connect(): void {\n    document.addEventListener('keyup', this.onKeyUp, true)\n    document.addEventListener('keydown', this.onKeyDown, true)\n    this.connected = true\n  }\n\n  disconnect(): void {\n    document.removeEventListener('keyup', this.onKeyUp, true)\n    document.removeEventListener('keydown', this.onKeyDown, true)\n    this.connected = false\n  }\n\n  update(): void {\n    if (this.type === 'continuous' && !this.damper.reachedTarget()) {\n      this.damper.update()\n      this.dispatchEvent({\n        type: 'update',\n        values: this.damper.getCurrentValues(),\n        deltas: this.damper.getDeltaValues(),\n      } as KeyboardAdaptorContinuousEvent)\n      if (this.damper.reachedTarget()) {\n        this.damper.resetAll(0)\n        this.dispatchEvent({\n          type: 'inertiacomplete',\n        } as IntertiaCompleteEvent)\n      }\n    }\n  }\n\n  isEnabled(): boolean {\n    return this.connected\n  }\n\n  private onKeyUp(event: KeyboardEvent): void {\n    if (this.type === 'discrete') {\n      for (const name in this.keyMapping) {\n        if (this.keyMapping[name].includes(event.key)) {\n          if (this.preventBubbling) event.preventDefault()\n          this.dispatchEvent({\n            type: 'trigger',\n            trigger: name,\n          } as KeyboardAdaptorDiscreteEvent)\n          break\n        }\n      }\n    }\n  }\n\n  private onKeyDown(event: KeyboardEvent): void {\n    if (this.type === 'continuous') {\n      for (const name in this.keyMapping) {\n        if (this.keyMapping[name].includes(event.key)) {\n          if (this.preventBubbling) event.preventDefault()\n          this.damper.addToTarget(name, this.incrementor)\n          break\n        }\n      }\n    }\n  }\n}\n","import { BaseAdaptor, ContinuousEvent, IntertiaCompleteEvent } from './BaseAdaptor'\nimport { Damper, DamperValues } from '../Damper'\n\ninterface Coordinates extends DamperValues {\n  x: number\n  y: number\n}\n\n/**\n * Event: Fired when when `PointerEvent`s are triggered\n * @example\n * ```javascript\n * adaptor.on('trigger', (e) => {\n *   console.log('x/y coordinates', e.values.x, e.values.y)\n * })\n * ```\n * */\nexport interface PointerAdaptorEvent extends ContinuousEvent {\n  /** Dampened x and y pointer coordinates */\n  values: Coordinates\n  /** Pointer coordinate change since previous update */\n  deltas: Coordinates\n  /** Number of pointers registered */\n  pointerCount: number\n}\n\nexport interface PointerAdaptorProps {\n  /** DOM element that should listen for pointer events. Defaults to `document.body` */\n  domElement?: HTMLElement\n  /** Damping value between 0 and 1. Defaults to 0.5 */\n  dampingFactor?: number\n  /** Whether to normalize the pointer position values. Defaults to true */\n  shouldNormalize?: boolean\n  /** If values are normalized, whether they should be in -1 to 1 range. Defaults to true. */\n  normalizeAroundZero?: boolean\n  /** Debounce for registering a change in the pointer count, in ms. Defaults to 100. */\n  multipointerThreshold?: number\n}\n\n/**\n * Parse pointer events to emit dampened, normalized coordinates along with the pointer count (for detecting multi-touch or drag events)\n * @remarks\n * Note: CSS property `touch-action: none` will probably be needed on listener element\n * @example Pointer adaptor\n * ```javascript\n * const pointerAdaptor = new PointerAdaptor()\n * pointerAdaptor.connect()\n * pointerAdaptor.addEventListener('update', (event) => {\n *  switch(event.pointerCount) {\n *    case 0:\n *      cube.scale.x = event.values.x\n *      cube.scale.y = event.values.y\n *      break\n *    case 1:\n *      cube.position.x += event.deltas.x\n *      cube.position.y -= event.deltas.y\n *      break\n *    default:\n *      break\n *  }\n * })\n *\n * // in RAF loop:\n * function animate(t) {\n *  pointerAdaptor.update(t)\n * }\n * ```\n */\nexport class PointerAdaptor extends BaseAdaptor {\n  private damper: Damper\n  private dampingFactor = 0.5\n  private connected: boolean\n  private domElement = document.body\n  private shouldNormalize = true\n  private normalizeAroundZero = true\n  private width: number\n  private height: number\n  private pointerCount = 0\n  private recordedPosition = false\n  private cache: Array<PointerEvent> = []\n  private lastDownTime = 0\n  private lastUpTime = 0\n  private multipointerThreshold = 100\n\n  constructor(props: PointerAdaptorProps) {\n    super()\n    Object.assign(this, props)\n    this.damper = new Damper({\n      values: { x: null, y: null },\n      dampingFactor: this.dampingFactor,\n    })\n    this.setDimensions()\n    this.onPointerMove = this.onPointerMove.bind(this)\n    this.onPointerUp = this.onPointerUp.bind(this)\n    this.onPointerDown = this.onPointerDown.bind(this)\n    this.onResize = this.onResize.bind(this)\n  }\n\n  connect(): void {\n    this.domElement.addEventListener('pointermove', this.onPointerMove, { passive: true })\n    this.domElement.addEventListener('pointerdown', this.onPointerDown, { passive: true })\n    this.domElement.addEventListener('pointerleave', this.onPointerUp, { passive: true })\n    this.domElement.addEventListener('pointerup', this.onPointerUp, { passive: true })\n    window.addEventListener('resize', this.onResize)\n    this.connected = true\n  }\n\n  disconnect(): void {\n    this.domElement.removeEventListener('pointermove', this.onPointerMove)\n    this.domElement.removeEventListener('pointerdown', this.onPointerDown)\n    this.domElement.removeEventListener('pointerleave', this.onPointerUp)\n    this.domElement.removeEventListener('pointerup', this.onPointerUp)\n    this.connected = false\n  }\n\n  update(time: number): void {\n    if (\n      this.pointerCount !== this.cache.length &&\n      time - this.lastDownTime > this.multipointerThreshold &&\n      time - this.lastUpTime > this.multipointerThreshold\n    ) {\n      this.pointerCount = this.cache.length\n      if (this.pointerCount === 0) {\n        this.damper.resetAll(null)\n        this.recordedPosition = false\n      } else {\n        this.damper.resetData(this.getPointerPosition(this.cache[0]))\n        this.recordedPosition = true\n      }\n    }\n\n    if (!this.damper.reachedTarget()) {\n      this.damper.update()\n      this.dispatchEvent({\n        type: 'update',\n        values: this.shouldNormalize\n          ? this.normalize(this.damper.getCurrentValues() as Coordinates, this.normalizeAroundZero)\n          : this.damper.getCurrentValues(),\n        deltas: this.shouldNormalize\n          ? this.normalize(this.damper.getDeltaValues() as Coordinates, false)\n          : this.damper.getDeltaValues(),\n        pointerCount: this.pointerCount,\n      } as PointerAdaptorEvent)\n      if (this.damper.reachedTarget()) {\n        this.dispatchEvent({ type: 'inertiacomplete' } as IntertiaCompleteEvent)\n      }\n    }\n  }\n\n  isEnabled(): boolean {\n    return this.connected\n  }\n\n  private setDimensions(): void {\n    this.width = this.domElement.getBoundingClientRect().width\n    this.height = this.domElement.getBoundingClientRect().height\n  }\n\n  private getPointerPosition(event: PointerEvent): Coordinates {\n    // event.offsetLeft is still experimental\n    return {\n      x: Math.max(0, Math.min(this.width, event.x - this.domElement.offsetLeft)),\n      y: Math.max(0, Math.min(this.height, event.y - this.domElement.offsetTop)),\n    }\n  }\n\n  private normalize(values: Coordinates, aroundZero: boolean): Coordinates {\n    let x = values.x / this.width\n    let y = values.y / this.height\n    if (aroundZero) {\n      x = x * 2 - 1\n      y = y * 2 - 1\n    }\n    return { x, y }\n  }\n\n  private onPointerMove(event: PointerEvent): void {\n    if (this.pointerCount === this.cache.length) {\n      if (this.cache.length === 0) {\n        if (!this.recordedPosition) {\n          this.damper.resetData(this.getPointerPosition(event))\n          this.recordedPosition = true\n        } else {\n          this.damper.setTarget(this.getPointerPosition(event))\n        }\n      } else {\n        if (event.pointerId === this.cache[0].pointerId) {\n          this.damper.setTarget(this.getPointerPosition(event))\n        }\n      }\n    }\n  }\n\n  private onPointerDown(event: PointerEvent): void {\n    // only deals with left mouse button right now\n    // TODO: add some logic for optional right button events\n    if (event.button === 0) {\n      this.cache.push(event)\n      this.lastDownTime = window.performance.now()\n    }\n  }\n\n  private onPointerUp(event: PointerEvent): void {\n    if (event.button === 0 || event.type === 'pointerleave') {\n      for (let i = 0; i < this.cache.length; i++) {\n        if (this.cache[i].pointerId == event.pointerId) {\n          this.cache.splice(i, 1)\n          break\n        }\n      }\n      this.lastUpTime = window.performance.now()\n    }\n  }\n\n  private onResize(): void {\n    this.setDimensions()\n  }\n}\n","import { BaseAdaptor, ContinuousEvent, IntertiaCompleteEvent } from './BaseAdaptor'\nimport { Damper, DamperValues } from '../Damper'\n\n/**\n * Each property has a 0-1 value, representing the area that has scrolled into view.\n * `head` is percentage the first 100vh of the scroll div,\n * `foot` is the last 100vh, and `body` is the area in between. `total` represents\n * the percentage scrolled of the entire div.\n * */\nexport interface ScrollPercentages extends DamperValues {\n  head: number\n  body: number\n  foot: number\n  total: number\n}\n\n/**\n * Payload signature for a scroll event. Includes true and dampened values,\n * incase real time values are needed\n */\nexport interface ScrollAdaptorEvent extends ContinuousEvent {\n  values: ScrollPercentages\n  dampenedValues: ScrollPercentages\n}\n\nexport interface ScrollAdaptorProps {\n  /** Long DOM Element to observe */\n  scrollElement: HTMLElement\n  /** Scroll element's parent, to gather scroll values from. Defaults to window */\n  scrollParent?: HTMLElement\n  /** Value between 0 and 1. Defaults to 0.5 */\n  dampingFactor?: number\n}\n\n/**\n * Emits normalized values for the amount a given DOM element has been scrolled through.\n * @example Scroll adaptor\n * ```javascript\n * const scrollAdaptor = new WheelAdaptor({ scrollElement: document.querySelector('.scroller'), dampingFactor: 0.1 })\n * scrollAdaptor.connect()\n * scrollAdaptor.addEventListener('update', (event) => {\n *   cube.rotation.y = event.total*Math.PI*2\n * })\n * ```\n */\nexport class ScrollAdaptor extends BaseAdaptor {\n  private scrollElement: HTMLElement\n  private scrollParent: HTMLElement\n  private observer: IntersectionObserver\n  private damper: Damper\n  private dampingFactor = 0.5\n  private connected: boolean\n  private isIntersecting = false\n  private values: ScrollPercentages\n  private lastSeenScrollValue: number\n\n  constructor(props: ScrollAdaptorProps) {\n    super()\n    Object.assign(this, props)\n    this.values = {\n      head: 0,\n      body: 0,\n      foot: 0,\n      total: 0,\n    }\n    this.lastSeenScrollValue = 0\n    this.damper = new Damper({\n      values: this.values,\n      dampingFactor: this.dampingFactor,\n    })\n    this.onIntersected = this.onIntersected.bind(this)\n    this.observer = new IntersectionObserver(this.onIntersected)\n  }\n\n  connect(): void {\n    this.observer.observe(this.scrollElement)\n    this.connected = true\n  }\n\n  disconnect(): void {\n    this.observer.unobserve(this.scrollElement)\n    this.connected = false\n  }\n\n  //TODO set this to work for any arbitary parent div\n  update(): void {\n    if (\n      this.isIntersecting &&\n      this.lastSeenScrollValue !== (this.scrollParent ? this.scrollParent.scrollTop : window.scrollY)\n    ) {\n      this.lastSeenScrollValue = this.scrollParent ? this.scrollParent.scrollTop : window.scrollY\n      const bounds = this.scrollElement.getBoundingClientRect()\n      this.values.head = this.normalize(bounds.top, window.innerHeight, 0)\n      this.values.foot = this.normalize(bounds.bottom, window.innerHeight, 0)\n      this.values.body = this.normalize(bounds.top, 0, window.innerHeight - bounds.height)\n      this.values.total = this.normalize(bounds.top, window.innerHeight, -bounds.height)\n      this.damper.setTarget(this.values)\n    }\n    if (!this.damper.reachedTarget()) {\n      this.damper.update()\n      this.dispatchEvent({\n        type: 'update',\n        dampenedValues: this.damper.getCurrentValues(),\n        values: this.values,\n      } as ScrollAdaptorEvent)\n      if (this.damper.reachedTarget()) {\n        this.dispatchEvent({ type: 'inertiacomplete' } as IntertiaCompleteEvent)\n      }\n    }\n  }\n\n  isEnabled(): boolean {\n    return this.connected\n  }\n\n  private normalize(value: number, start: number, end: number): number {\n    const mapped = (value - start) / (end - start)\n    return Math.max(0, Math.min(1, mapped))\n  }\n\n  private onIntersected(entries: IntersectionObserverEntry[]): void {\n    const entry = entries[0] // only 1 element to observe\n    this.isIntersecting = entry.isIntersecting\n  }\n}\n","import { BaseAdaptor, DiscreteEvent } from './BaseAdaptor'\n\n/**\n * Payload signature for a swipe event.\n * The sign represents the direction of the swipe,\n * y = 1 when swiping down-to-up, and x = 1 when swiping left-to-right\n * */\nexport interface SwipeAdaptorEvent extends DiscreteEvent {\n  x: -1 | 1 | 0\n  y: -1 | 1 | 0\n}\n\nexport interface SwipeAdaptorProps {\n  /** DOM element to listen to events on. Defaults to document.body */\n  domElement?: HTMLElement\n  /** Threshold of pointer's deltaX to trigger events. Defaults to 60 */\n  thresholdX?: number\n  /** Threshold of pointer's deltaY to trigger events. Defaults to 60 */\n  thresholdY?: number\n}\n\n/**\n * Emits events in response to swipe gestures above a given threshold.\n * @remarks\n * Note: CSS property `touch-action: none` will probably be needed on listener element\n * @example Swipe adaptor\n * ```javascript\n * const swipeAdaptor = new SwipeAdaptor()\n * swipeAdaptor.connect()\n * swipeAdaptor.addEventListener('trigger', (event) => {\n *   cube.scale.y += event.y*0.1\n * })\n * ```\n */\nexport class SwipeAdaptor extends BaseAdaptor {\n  private domElement = document.body\n  private thresholdX = 60\n  private thresholdY = 60\n  private startX: number\n  private startY: number\n  private connected: boolean\n\n  constructor(props: SwipeAdaptorProps = {}) {\n    super()\n    Object.assign(this, props)\n    this.onPointerUp = this.onPointerUp.bind(this)\n    this.onPointerDown = this.onPointerDown.bind(this)\n  }\n\n  connect(): void {\n    this.domElement.addEventListener('pointerdown', this.onPointerDown, { passive: true })\n    this.domElement.addEventListener('pointerup', this.onPointerUp, { passive: true })\n    this.connected = true\n  }\n\n  disconnect(): void {\n    this.domElement.removeEventListener('pointerdown', this.onPointerDown)\n    this.domElement.removeEventListener('pointerup', this.onPointerUp)\n    this.connected = false\n  }\n\n  update(): void {\n    // nothing to do here\n  }\n\n  isEnabled(): boolean {\n    return this.connected\n  }\n\n  private onPointerDown(event: PointerEvent): void {\n    if (event.pointerType !== 'mouse' && event.isPrimary) {\n      this.startX = event.screenX\n      this.startY = event.screenY\n    }\n  }\n\n  private onPointerUp(event: PointerEvent): void {\n    if (event.pointerType !== 'mouse' && event.isPrimary) {\n      const diffX = event.screenX - this.startX\n      const diffY = event.screenY - this.startY\n      if (Math.abs(diffX) >= this.thresholdX || Math.abs(diffY) >= this.thresholdY) {\n        this.dispatchEvent({\n          type: 'trigger',\n          x: Math.abs(diffX) >= this.thresholdX ? Math.sign(diffX) : 0,\n          y: Math.abs(diffY) >= this.thresholdY ? Math.sign(-1 * diffY) : 0,\n        } as SwipeAdaptorEvent)\n      }\n    }\n  }\n}\n","import { BaseAdaptor, DiscreteEvent, ContinuousEvent, IntertiaCompleteEvent } from './BaseAdaptor'\nimport { Damper, DamperValues } from '../Damper'\n\n/**\n * Payload signature for a discrete wheel event.\n * The sign represents the direction of the wheel event that caused the event to trigger\n * */\nexport interface WheelAdaptorDiscreteEvent extends DiscreteEvent {\n  x: -1 | 1 | 0\n  y: -1 | 1 | 0\n}\n\n/**\n * Payload signature for a continuous wheel event.\n * DamperValues have `x` and `y` keys.\n */\nexport interface WheelAdaptorContinuousEvent extends ContinuousEvent {\n  values: DamperValues\n  deltas: DamperValues\n}\n\n/**\n * A discrete adaptor works as a trigger - only firing events when wheel events pass a given threshold,\n * whereas a continuous adaptor continuously fires events on wheel\n * */\nexport type WheelAdaptorType = 'discrete' | 'continuous'\n\nexport interface WheelAdaptorProps {\n  type: WheelAdaptorType\n  /** DOM element to listen to events on. Defaults to window */\n  domElement?: HTMLElement\n  /** Only used for continuous adaptor, value between 0 and 1. Defaults to 0.5 */\n  dampingFactor?: number\n  /** Only used for discrete adaptor, threshold of wheel.deltaX to trigger events. Defaults to 15 */\n  thresholdX?: number\n  /** Only used for discrete adaptor, threshold of wheel.deltaY to trigger events. Defaults to 15 */\n  thresholdY?: number\n  /** Only used for discrete adaptor, rest duration between firing trigger events. Defaults to 700 */\n  debounceDuration?: number\n}\n\n/**\n * Parse mouse wheel events and emit either dampened values, or trigger events for swipes that cross a given threshold.\n * @example Discrete adaptor\n * ```javascript\n * const wheelAdaptor = new WheelAdaptor({ type: 'discrete' })\n * wheelAdaptor.connect()\n * wheelAdaptor.addEventListener('trigger', (event) => {\n *   cube.scale.y += event.y*0.1\n * })\n * ```\n */\nexport class WheelAdaptor extends BaseAdaptor {\n  private type: WheelAdaptorType\n  private domElement: HTMLElement\n  private dampingFactor = 0.5\n  private damper: Damper\n  private thresholdX = 15\n  private thresholdY = 15\n  private debounceDuration = 700\n  private lastThresholdTrigger = 0\n  private connected: boolean\n\n  constructor(props: WheelAdaptorProps) {\n    super()\n    Object.assign(this, props)\n    this.damper = new Damper({\n      values: { x: 0, y: 0 },\n      dampingFactor: this.dampingFactor,\n    })\n    this.onWheel = this.onWheel.bind(this)\n  }\n\n  connect(): void {\n    const element = this.domElement || window\n    element.addEventListener('wheel', this.onWheel, { passive: true })\n    this.connected = true\n  }\n\n  disconnect(): void {\n    const element = this.domElement || window\n    element.removeEventListener('wheel', this.onWheel)\n    this.connected = false\n  }\n\n  update(): void {\n    if (this.type === 'continuous' && !this.damper.reachedTarget()) {\n      this.damper.update()\n      this.dispatchEvent({\n        type: 'update',\n        values: this.damper.getCurrentValues(),\n        deltas: this.damper.getDeltaValues(),\n      } as WheelAdaptorContinuousEvent)\n      if (this.damper.reachedTarget()) {\n        this.damper.resetAll(0)\n        this.dispatchEvent({\n          type: 'inertiacomplete',\n        } as IntertiaCompleteEvent)\n      }\n    }\n  }\n\n  isEnabled(): boolean {\n    return this.connected\n  }\n\n  private onWheel(event: WheelEvent): void {\n    if (this.type === 'continuous') {\n      this.damper.addToTarget('x', event.deltaX)\n      this.damper.addToTarget('y', event.deltaY)\n    } else if (this.type === 'discrete') {\n      if (Math.abs(event.deltaX) >= this.thresholdX || Math.abs(event.deltaY) >= this.thresholdY) {\n        const now = window.performance.now()\n        if (now - this.lastThresholdTrigger > this.debounceDuration) {\n          this.lastThresholdTrigger = now\n          this.dispatchEvent({\n            type: 'trigger',\n            x: Math.abs(event.deltaX) >= this.thresholdX ? Math.sign(event.deltaX) : 0,\n            y: Math.abs(event.deltaY) >= this.thresholdY ? Math.sign(event.deltaY) : 0,\n          } as WheelAdaptorDiscreteEvent)\n        }\n      }\n    }\n  }\n}\n","import { BaseControls } from './BaseControls'\nimport { CameraRig, CameraAction } from '../CameraRig'\nimport { KeyboardAdaptor } from '../adaptors/KeyboardAdaptor'\nimport { PointerAdaptor } from '../adaptors/PointerAdaptor'\nimport { WheelAdaptor } from '../adaptors/WheelAdaptor'\n\nexport interface FreeMovementControlsProps {\n  domElement?: HTMLElement\n  /* Damping factor between 0 and 1. Defaults to 0.3 */\n  pointerDampFactor?: number\n  /* Damping factor between 0 and 1. Defaults to 0.5 */\n  keyboardDampFactor?: number\n  /* Damping factor between 0 and 1. Defaults to 0.25 */\n  wheelDampFactor?: number\n  /* Mutiplier for keyboard translation. Defaults to 0.5 */\n  keyboardScaleFactor?: number\n  /* Mutiplier for wheel translation. Defaults to 0.05 */\n  wheelScaleFactor?: number\n  /* Mutiplier for two-pointer translation. Defaults to 4 */\n  pointerScaleFactor?: number\n  /* Mutiplier for panning. Defaults to Math.PI / 4 */\n  panDegreeFactor?: number\n  /* Mutiplier for tilting. Defaults to Math.PI / 10 */\n  tiltDegreeFactor?: number\n}\n\n/**\n * Control scheme to move the camera with arrow/WASD keys and mouse wheel; and rotate the camera with click-and-drag events.\n * @example\n * ```js\n * const scene = new Scene()\n * const camera = new PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)\n * const cameraRig = new CameraRig(camera, scene)\n * const controls = new FreeMovementControls(cameraRig)\n *\n * controls.enable()\n * function animate(t) {\n *  // render loop\n *  controls.update(t)\n * }\n * ```\n */\nexport class FreeMovementControls implements BaseControls {\n  readonly cameraRig: CameraRig\n  private keyboardAdaptor: KeyboardAdaptor\n  private wheelAdaptor: WheelAdaptor\n  private pointerAdaptor: PointerAdaptor\n  private wheelScaleFactor: number\n  private pointerScaleFactor: number\n  private panDegreeFactor: number\n  private tiltDegreeFactor: number\n  private enabled = false\n\n  constructor(cameraRig: CameraRig, props: FreeMovementControlsProps = {}) {\n    this.cameraRig = cameraRig\n\n    this.wheelScaleFactor = props.wheelScaleFactor || 0.05\n    this.pointerScaleFactor = props.pointerScaleFactor || 4\n    this.panDegreeFactor = props.panDegreeFactor || Math.PI / 4\n    this.tiltDegreeFactor = props.tiltDegreeFactor || Math.PI / 10\n\n    this.keyboardAdaptor = new KeyboardAdaptor({\n      type: 'continuous',\n      dampingFactor: props.keyboardDampFactor || 0.5,\n      incrementor: props.keyboardScaleFactor || 0.5,\n      keyMapping: {\n        forward: ['ArrowUp', 'w', 'W'],\n        backward: ['ArrowDown', 's', 'S'],\n        left: ['ArrowLeft', 'a', 'A'],\n        right: ['ArrowRight', 'd', 'D'],\n        up: ['t', 'T'],\n        down: ['b', 'B'],\n      },\n    })\n\n    this.wheelAdaptor = new WheelAdaptor({\n      type: 'continuous',\n      dampingFactor: props.wheelDampFactor || 0.25,\n      domElement: props.domElement || document.body,\n    })\n\n    this.pointerAdaptor = new PointerAdaptor({\n      dampingFactor: props.pointerDampFactor || 0.3,\n    })\n\n    this.onWheel = this.onWheel.bind(this)\n    this.onKey = this.onKey.bind(this)\n    this.onPointer = this.onPointer.bind(this)\n  }\n\n  isEnabled(): boolean {\n    return this.enabled\n  }\n\n  enable(): void {\n    this.wheelAdaptor.connect()\n    this.keyboardAdaptor.connect()\n    this.pointerAdaptor.connect()\n    this.wheelAdaptor.addEventListener('update', this.onWheel)\n    this.keyboardAdaptor.addEventListener('update', this.onKey)\n    this.pointerAdaptor.addEventListener('update', this.onPointer)\n    this.enabled = true\n  }\n\n  disable(): void {\n    this.wheelAdaptor.disconnect()\n    this.keyboardAdaptor.disconnect()\n    this.pointerAdaptor.disconnect()\n    this.wheelAdaptor.removeEventListener('update', this.onWheel)\n    this.keyboardAdaptor.removeEventListener('update', this.onKey)\n    this.pointerAdaptor.removeEventListener('update', this.onPointer)\n    this.enabled = false\n  }\n\n  private onWheel(event): void {\n    this.cameraRig.do(CameraAction.Dolly, event.deltas.y * this.wheelScaleFactor)\n    this.cameraRig.do(CameraAction.Truck, event.deltas.x * this.wheelScaleFactor)\n  }\n\n  private onKey(event): void {\n    this.cameraRig.do(CameraAction.Dolly, event.values.backward - event.values.forward)\n    this.cameraRig.do(CameraAction.Truck, event.values.right - event.values.left)\n    this.cameraRig.do(CameraAction.Pedestal, event.values.up - event.values.down)\n  }\n\n  private onPointer(event): void {\n    switch (event.pointerCount) {\n      case 1:\n        this.cameraRig.do(CameraAction.Pan, event.deltas.x * this.panDegreeFactor)\n        this.cameraRig.do(CameraAction.Tilt, event.deltas.y * this.tiltDegreeFactor)\n        break\n      case 2:\n        this.cameraRig.do(CameraAction.Dolly, -event.deltas.y * this.pointerScaleFactor)\n        this.cameraRig.do(CameraAction.Truck, -event.deltas.x * this.pointerScaleFactor)\n        break\n      default:\n        break\n    }\n  }\n\n  update(time: number): void {\n    if (this.enabled) {\n      this.keyboardAdaptor.update()\n      this.wheelAdaptor.update()\n      this.pointerAdaptor.update(time)\n    }\n  }\n}\n","import { BaseControls } from './BaseControls'\nimport { CameraRig } from '../CameraRig'\nimport { ScrollAdaptor } from '../adaptors/ScrollAdaptor'\n\nexport interface ScrollControlsProps {\n  scrollElement: HTMLElement\n  scrollParent?: HTMLElement\n  dampingFactor?: number\n}\n\n/**\n * Control scheme to scrub through the CameraRig's `AnimationClip` based on the scroll of a DOM Element\n * @example\n * ```js\n * const scene = new Scene()\n * const gltfLoader = new GLTFLoader()\n * let camera, cameraRig, controls\n *\n * gltfLoader.load(cameraPath, (gltf) => {\n *  camera = gltf.cameras[0]\n *  cameraRig = new CameraRig(gltf.cameras[0], scene, { animationClip: gltf.animations[0] })\n *  controls = new ScrollControls(cameraRig, {\n *    scrollElement: document.querySelector('.scroller')\n *  })\n *  controls.enable()\n * })\n *\n * function animate() {\n *  // render loop\n *  controls.update()\n * }\n * ```\n */\nexport class ScrollControls implements BaseControls {\n  readonly cameraRig: CameraRig\n  private scrollAdaptor: ScrollAdaptor\n  private enabled = false\n\n  constructor(cameraRig: CameraRig, props: ScrollControlsProps) {\n    this.cameraRig = cameraRig\n    this.cameraRig.setAnimationTime(0)\n\n    this.scrollAdaptor = new ScrollAdaptor({\n      scrollElement: props.scrollElement,\n      scrollParent: props.scrollParent,\n      dampingFactor: props.dampingFactor || 1,\n    })\n\n    this.onScroll = this.onScroll.bind(this)\n  }\n\n  isEnabled(): boolean {\n    return this.enabled\n  }\n\n  enable(): void {\n    this.scrollAdaptor.connect()\n    this.scrollAdaptor.addEventListener('update', this.onScroll)\n    this.enabled = true\n  }\n\n  disable(): void {\n    this.scrollAdaptor.disconnect()\n    this.scrollAdaptor.removeEventListener('update', this.onScroll)\n    this.enabled = false\n  }\n\n  update(): void {\n    if (this.enabled) {\n      this.scrollAdaptor.update()\n    }\n  }\n\n  private onScroll(event): void {\n    this.cameraRig.setAnimationPercentage(event.values.total)\n  }\n}\n","import { EventDispatcher, Vector3, Quaternion } from 'three'\nimport { BaseControls } from './BaseControls'\nimport { CameraRig } from '../CameraRig'\n\nexport interface StoryPointMarker {\n  lookAtPosition: Vector3\n  lookAtOrientation: Quaternion\n}\n\n/**\n * Payload signature for event fired when nextPOI/prevPOI are invoked\n * when at last/first POI (ie there is no POI to go to)\n * */\nexport interface ExitStoryPointsEvent {\n  type: 'ExitStoryPoints'\n  exitFrom: 'start' | 'end'\n}\n\nexport interface StoryPointsControlsProps {\n  /**\n   * Whether to cycle to the first/last POI after reaching the end/start.\n   * When false, controls with emit 'ExitStoryPoints' events. Defaults to false.\n   * */\n  cycle?: boolean\n  /** Transition duration, defaults to 1 */\n  duration?: number\n  /** Transition easing, defaults to power1 */\n  ease?: string\n}\n\n/**\n * Control scheme to transition the camera between given points in world space.\n * @example\n * ```js\n *\n * const pois = [\n *  { lookAtPosition: new Vector3(...), lookAtOrientation: new Quaternion(...) },\n *  { lookAtPosition: new Vector3(...), lookAtOrientation: new Quaternion(...) },\n * ]\n * const scene = new Scene()\n * const camera = new PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)\n * const cameraRig = new CameraRig(camera, scene)\n * const controls = new StoryPointsControls(cameraRig, pois)\n *\n * controls.enable()\n * controls.goToPOI(0)\n * controls.addEventListener('ExitStoryPoints', (e) => {\n *  alert(`Exit story points from _${e.exitFrom}_ event fired`)\n * })\n *\n * // assuming some 'nextBtn' and 'prevBtn' dom elements have been created\n * nextBtn.on('click', () => controls.nextPOI() )\n * prevBtn.on('click', () => controls.prevPOI() )\n * ```\n */\nexport class StoryPointsControls extends EventDispatcher implements BaseControls {\n  readonly cameraRig: CameraRig\n  private pois: StoryPointMarker[]\n  private currentIndex: number | null = null\n  private upcomingIndex: number | null = null\n  private enabled = false\n  private cycle = false\n  private duration: number\n  private ease: string\n\n  constructor(cameraRig: CameraRig, pois: StoryPointMarker[] = [], props: StoryPointsControlsProps = {}) {\n    super()\n    this.cameraRig = cameraRig\n    this.pois = pois\n    Object.assign(this, props)\n    this.onCameraStart = this.onCameraStart.bind(this)\n    this.onCameraUpdate = this.onCameraUpdate.bind(this)\n    this.onCameraEnd = this.onCameraEnd.bind(this)\n  }\n\n  getCurrentIndex(): number {\n    return this.currentIndex\n  }\n\n  nextPOI(): void {\n    const next = this.currentIndex + 1\n    if (next >= this.pois.length && !this.cycle) {\n      this.dispatchEvent({\n        type: 'ExitStoryPoints',\n        exitFrom: 'end',\n      } as ExitStoryPointsEvent)\n    } else {\n      this.goToPOI(next % this.pois.length)\n    }\n  }\n\n  prevPOI(): void {\n    const prev = this.currentIndex - 1\n    if (prev < 0 && !this.cycle) {\n      this.dispatchEvent({\n        type: 'ExitStoryPoints',\n        exitFrom: 'start',\n      } as ExitStoryPointsEvent)\n    } else {\n      this.goToPOI((prev + this.pois.length) % this.pois.length)\n    }\n  }\n\n  goToPOI(index: number): void {\n    this.upcomingIndex = index\n    const poi = this.pois[this.upcomingIndex]\n    this.cameraRig.flyTo(poi.lookAtPosition, poi.lookAtOrientation, this.duration, this.ease)\n  }\n\n  enable(): void {\n    this.cameraRig.addEventListener('CameraMoveStart', this.onCameraStart)\n    this.cameraRig.addEventListener('CameraMoveUpdate', this.onCameraUpdate)\n    this.cameraRig.addEventListener('CameraMoveEnd', this.onCameraEnd)\n    this.enabled = true\n  }\n\n  disable(): void {\n    this.cameraRig.removeEventListener('CameraMoveStart', this.onCameraStart)\n    this.cameraRig.removeEventListener('CameraMoveUpdate', this.onCameraUpdate)\n    this.cameraRig.removeEventListener('CameraMoveEnd', this.onCameraEnd)\n    this.enabled = false\n  }\n\n  update(): void {\n    // nothing to do here\n  }\n\n  isEnabled(): boolean {\n    return this.enabled\n  }\n\n  private updatePois(progress: number): void {\n    this.dispatchEvent({\n      type: 'update',\n      currentIndex: this.currentIndex,\n      upcomingIndex: this.upcomingIndex,\n      progress,\n    })\n  }\n\n  private onCameraStart(): void {\n    this.updatePois(0)\n  }\n\n  private onCameraUpdate(event): void {\n    this.updatePois(event.progress)\n  }\n\n  private onCameraEnd(): void {\n    this.currentIndex = this.upcomingIndex\n    this.upcomingIndex = null\n  }\n}\n","import { EventDispatcher } from 'three'\nimport { BaseControls } from './BaseControls'\nimport { CameraRig } from '../CameraRig'\nimport { KeyboardAdaptor } from '../adaptors/KeyboardAdaptor'\nimport { WheelAdaptor } from '../adaptors/WheelAdaptor'\nimport { SwipeAdaptor } from '../adaptors/SwipeAdaptor'\n\nexport interface PathPointMarker {\n  frame: number\n}\n/**\n * Payload signature for event fired on user input when there\n * is no next/prev POI to go to\n * */\nexport interface ExitPathPointsEvent {\n  type: 'ExitPathPoints'\n  exitFrom: 'start' | 'end'\n}\n\nexport interface PathPointsControlsProps {\n  /** Threshold of wheel delta that triggers a transition. Defaults to 15 */\n  wheelThreshold?: number\n  /** Threshold of swipe distance that triggers a transition. Defaults to 60 */\n  swipeThreshold?: number\n  /** Transition duration, defaults to 1 */\n  duration?: number\n  /** Transition easing, defaults to power1 */\n  ease?: string\n}\n\n/**\n * Control scheme to transition the camera between specific points (frames) along a path specified through an `AnimationClip`.\n * @example\n * ```js\n *\n * const pois = [ { frame: 0 }, { frame: 54 } ....]\n * const scene = new Scene()\n * const gltfLoader = new GLTFLoader()\n * let camera, cameraRig, controls\n *\n * gltfLoader.load(cameraPath, (gltf) => {\n *  camera = gltf.cameras[0]\n *  cameraRig = new CameraRig(gltf.cameras[0], scene, { animationClip: gltf.animations[0] })\n *  controls = new PathPointsControls(cameraRig, pois)\n *  pois[0].show(1)\n *  controls.enable()\n *  controls.addEventListener('ExitPathPoints', (e) => {\n *    alert(`Exit path points from _${e.exitFrom}_ event fired`)\n *  })\n * })\n * ```\n */\nexport class PathPointsControls extends EventDispatcher implements BaseControls {\n  readonly cameraRig: CameraRig\n  private wheelAdaptor: WheelAdaptor\n  private swipeAdaptor: SwipeAdaptor\n  private keyboardAdaptor: KeyboardAdaptor\n  private pois: PathPointMarker[]\n  private currentIndex = 0\n  private upcomingIndex: number | null = null\n  private enabled = false\n  private duration: number\n  private ease: string\n  private wheelThreshold = 15\n  private swipeThreshold = 60\n\n  constructor(cameraRig: CameraRig, pois: PathPointMarker[] = [], props: PathPointsControlsProps = {}) {\n    super()\n    this.cameraRig = cameraRig\n    this.pois = pois\n    Object.assign(this, props)\n    this.wheelAdaptor = new WheelAdaptor({ type: 'discrete', thresholdY: this.wheelThreshold })\n    this.swipeAdaptor = new SwipeAdaptor({ thresholdY: this.swipeThreshold })\n    this.keyboardAdaptor = new KeyboardAdaptor({ type: 'discrete' })\n    this.onCameraStart = this.onCameraStart.bind(this)\n    this.onCameraUpdate = this.onCameraUpdate.bind(this)\n    this.onCameraEnd = this.onCameraEnd.bind(this)\n    this.onTrigger = this.onTrigger.bind(this)\n    this.onKey = this.onKey.bind(this)\n  }\n\n  getCurrentIndex(): number {\n    return this.currentIndex\n  }\n\n  enable(): void {\n    this.wheelAdaptor.addEventListener('trigger', this.onTrigger)\n    this.swipeAdaptor.addEventListener('trigger', this.onTrigger)\n    this.keyboardAdaptor.addEventListener('trigger', this.onKey)\n    this.cameraRig.addEventListener('CameraMoveStart', this.onCameraStart)\n    this.cameraRig.addEventListener('CameraMoveUpdate', this.onCameraUpdate)\n    this.cameraRig.addEventListener('CameraMoveEnd', this.onCameraEnd)\n    this.wheelAdaptor.connect()\n    this.swipeAdaptor.connect()\n    this.keyboardAdaptor.connect()\n    this.enabled = true\n  }\n\n  disable(): void {\n    this.wheelAdaptor.removeEventListener('trigger', this.onTrigger)\n    this.swipeAdaptor.removeEventListener('trigger', this.onTrigger)\n    this.keyboardAdaptor.removeEventListener('trigger', this.onKey)\n    this.cameraRig.removeEventListener('CameraMoveStart', this.onCameraStart)\n    this.cameraRig.removeEventListener('CameraMoveUpdate', this.onCameraUpdate)\n    this.cameraRig.removeEventListener('CameraMoveEnd', this.onCameraEnd)\n    this.wheelAdaptor.disconnect()\n    this.swipeAdaptor.disconnect()\n    this.keyboardAdaptor.disconnect()\n    this.enabled = false\n  }\n\n  update(): void {\n    // nothing to do here\n  }\n\n  isEnabled(): boolean {\n    return this.enabled\n  }\n\n  private onKey(event): void {\n    switch (event.trigger) {\n      case 'up':\n        this.onTrigger({ y: -1 })\n        break\n      case 'down':\n        this.onTrigger({ y: 1 })\n        break\n      default:\n        break\n    }\n  }\n\n  private onTrigger(event): void {\n    const index = this.currentIndex + event.y\n    if (index >= this.pois.length) {\n      this.dispatchEvent({\n        type: 'ExitPathPoints',\n        exitFrom: 'end',\n      } as ExitPathPointsEvent)\n    } else if (index < 0) {\n      this.dispatchEvent({\n        type: 'ExitPathPoints',\n        exitFrom: 'start',\n      } as ExitPathPointsEvent)\n    } else {\n      this.upcomingIndex = index\n      this.cameraRig.flyToKeyframe(this.pois[this.upcomingIndex].frame, this.duration, this.ease)\n    }\n  }\n\n  private updatePois(progress: number): void {\n    this.dispatchEvent({\n      type: 'update',\n      currentIndex: this.currentIndex,\n      upcomingIndex: this.upcomingIndex,\n      progress,\n    })\n  }\n\n  private onCameraStart(): void {\n    this.updatePois(0)\n  }\n\n  private onCameraUpdate(event): void {\n    this.updatePois(event.progress)\n  }\n\n  private onCameraEnd(): void {\n    this.currentIndex = this.upcomingIndex\n    this.upcomingIndex = null\n  }\n}\n","import { BaseControls } from './BaseControls'\nimport { CameraRig, CameraAction } from '../CameraRig'\nimport { PointerAdaptor } from '../adaptors/PointerAdaptor'\n\n//TODO: add option for relative or absolute control (in terms of screen space)\nexport interface ThreeDOFControlsProps {\n  /* Mutiplier for panning. Defaults to Math.PI / 20 */\n  panFactor?: number\n  /* Mutiplier for tilting. Defaults to Math.PI / 20 */\n  tiltFactor?: number\n  /* Mutiplier for truck translation. Defaults to 1 */\n  truckFactor?: number\n  /* Mutiplier for pedestal translation. Defaults to 1 */\n  pedestalFactor?: number\n  /* Damping factor between 0 and 1. Defaults to 0.7 */\n  dampingFactor?: number\n}\n\n/**\n * Control scheme for slight rotation and translation movement in response to mouse movements (designed to be used in conjunction with other control schemes)\n * @example\n * ```js\n * const scene = new Scene()\n * const camera = new PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)\n * const cameraRig = new CameraRig(camera, scene)\n * const controls = new ThreeDOFControls(cameraRig)\n *\n * controls.enable()\n * function animate(t) {\n *  // render loop\n *  controls.update(t)\n * }\n * ```\n */\nexport class ThreeDOFControls implements BaseControls {\n  readonly cameraRig: CameraRig\n  private pointerAdaptor: PointerAdaptor\n  private enabled = false\n  private panFactor = Math.PI / 20\n  private tiltFactor = Math.PI / 20\n  private truckFactor = 1\n  private pedestalFactor = 1\n  private dampingFactor = 0.7\n\n  constructor(cameraRig: CameraRig, props: ThreeDOFControlsProps = {}) {\n    this.cameraRig = cameraRig\n    Object.assign(this, props)\n    this.pointerAdaptor = new PointerAdaptor({\n      dampingFactor: this.dampingFactor,\n    })\n    this.onPointerMove = this.onPointerMove.bind(this)\n  }\n\n  isEnabled(): boolean {\n    return this.enabled\n  }\n\n  enable(): void {\n    this.pointerAdaptor.connect()\n    this.pointerAdaptor.addEventListener('update', this.onPointerMove)\n    this.enabled = true\n  }\n\n  disable(): void {\n    this.pointerAdaptor.disconnect()\n    this.pointerAdaptor.removeEventListener('update', this.onPointerMove)\n    this.enabled = false\n  }\n\n  update(time: number): void {\n    if (this.enabled) {\n      this.pointerAdaptor.update(time)\n    }\n  }\n\n  private onPointerMove(event): void {\n    if (event.pointerCount === 0) {\n      this.cameraRig.do(CameraAction.Pan, -event.deltas.x * this.panFactor)\n      this.cameraRig.do(CameraAction.Tilt, -event.deltas.y * this.tiltFactor)\n      this.cameraRig.do(CameraAction.LocalTruck, event.deltas.x * this.truckFactor)\n      this.cameraRig.do(CameraAction.LocalPedestal, event.deltas.y * this.pedestalFactor)\n    }\n  }\n}\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","TypeError","String","__","this","constructor","create","CameraAction","Axis","__assign","assign","t","s","i","n","arguments","length","apply","props","key","values","targetValues","deltaValues","dampingFactor","epsilon","hasReached","Damper","deltas","approached","Math","abs","target","value","ActionMappingByUpAxis","X","Pan","_b","Tilt","Z","Roll","Y","_a","_c","_d","camera","scene","_super","_this","upAxis","initRig","CameraRig","translationBox","Object3D","rotationBox","rotationElements","name","animationRotationObjectName","animationTranslationObjectName","rotation","order","getRotationOrder","first","actionAxes","second","third","add","cameraIsInRig","rigComponent","axis","degrees","rotateX","rotateY","rotateZ","action","translateAlong","rotateRigComponent","amount","translateX","translateY","translateZ","clip","translationObjectName","rotationObjectName","animationClip","hasAnimation","mixer","AnimationMixer","clipAction","play","setTime","respondsToActions","rotate","Truck","translateRigComponent","Pedestal","Dolly","LocalTruck","LocalPedestal","LocalDolly","Zoom","PerspectiveCamera","fov","updateProjectionMatrix","getWorldCoordinates","position","quaternion","copy","set","attach","join","Vector3","getWorldPosition","Quaternion","getWorldQuaternion","inTransit","currentAxes","currentPanObject","currentTiltObject","currentRollObject","duration","ease","isMoving","currentCoords","currentValues_1","px","x","py","y","pz","z","qx","qy","qz","qw","w","TweenMax","to","onStart","disassemble","dispatchEvent","type","onUpdate","tween","progress","onComplete","assemble","frame","currentValues_2","time","tracks","times","percentage","percent","max","min","EventDispatcher","up","down","left","right","keyMapping","damper","onKeyUp","bind","onKeyDown","KeyboardAdaptor","document","addEventListener","connected","removeEventListener","reachedTarget","update","getCurrentValues","getDeltaValues","resetAll","event","name_1","includes","preventBubbling","preventDefault","trigger","name_2","addToTarget","incrementor","BaseAdaptor","body","setDimensions","onPointerMove","onPointerUp","onPointerDown","onResize","PointerAdaptor","domElement","passive","window","pointerCount","cache","lastDownTime","multipointerThreshold","lastUpTime","recordedPosition","resetData","getPointerPosition","shouldNormalize","normalize","normalizeAroundZero","width","getBoundingClientRect","height","offsetLeft","offsetTop","aroundZero","setTarget","pointerId","button","push","performance","now","splice","head","foot","total","lastSeenScrollValue","onIntersected","observer","IntersectionObserver","ScrollAdaptor","observe","scrollElement","unobserve","isIntersecting","scrollParent","scrollTop","scrollY","bounds","top","innerHeight","bottom","dampenedValues","start","end","mapped","entries","entry","SwipeAdaptor","pointerType","isPrimary","startX","screenX","startY","screenY","diffX","diffY","thresholdX","thresholdY","sign","onWheel","WheelAdaptor","deltaX","deltaY","lastThresholdTrigger","debounceDuration","cameraRig","wheelScaleFactor","pointerScaleFactor","panDegreeFactor","PI","tiltDegreeFactor","keyboardAdaptor","keyboardDampFactor","keyboardScaleFactor","forward","backward","wheelAdaptor","wheelDampFactor","pointerAdaptor","pointerDampFactor","onKey","onPointer","FreeMovementControls","enabled","connect","disconnect","do","setAnimationTime","scrollAdaptor","onScroll","ScrollControls","setAnimationPercentage","pois","onCameraStart","onCameraUpdate","onCameraEnd","StoryPointsControls","currentIndex","next","cycle","exitFrom","goToPOI","prev","index","upcomingIndex","poi","flyTo","lookAtPosition","lookAtOrientation","updatePois","wheelThreshold","swipeAdaptor","swipeThreshold","onTrigger","PathPointsControls","flyToKeyframe","ThreeDOFControls","panFactor","tiltFactor","truckFactor","pedestalFactor"],"mappings":"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"}